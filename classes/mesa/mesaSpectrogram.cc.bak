#include "../tinyspline.h" // NURBS! NURBS! NURBS! 

#include "mesaNURBS.cc"
#include <time.h>
   
#define MAXSPECTROGRAMZ 100	
#define MAXLABELS 2
#define LABELYMAX 4
#define SHOWCONTROLPOINTS 1
#define DONTSHOWCONTROLPOINTS 0
#define POLYGONDEBUG 0


extern void GLAPIENTRY bandEQCB(GLfloat *vertex);

class mesaSpectrogram  
	{
	public:
		mesaSpectrogram(sign &_SIGNPOINTER);
		~mesaSpectrogram();
	
		mesaNURBS BAND;

		void drawSpectrogram(int _eyeX, int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ,int _sourceBlend,int _destinationBlend);
		void addRow(uint *_peak, uint *_peakThreshold);
		void drawPolygons(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ, int _offsetZ);
		void drawLineStrip(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ);
		void drawNURBSEQBand(int _x);
		void theSwitch(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ);
		void drawLabels(int _x,int _eyeX,int _eyeY);
		void queueLabel(int _x,int _z,int _eyeX, int _eyeY);
 		
		int inited;
   	int depth;
		int thresholdRange;
		sign *SIGNPOINTER;
		
   	uint bands;
	//	uint *peak;
		uint *peakThreshold;
		int xScale;
		int sg[SIGN_WIDTH][MAXSPECTROGRAMZ];
		
		float yEyeCentreOffset, zEyeCentreOffset;
		float bandSpacing;
		float yScale, zScale;

		int MAXPEAKAREA;
		int MAXPEAKLENGTH;
		float labelXScale, labelYScale;
		int polygonFace, polygonMode;
		int polygonRendering;
		float polygonColour;
		int zScaleMS;
				
		private:
			char labelString[10];
			void freqToString(float _freq,char *_labelString);
		 	void freqToNote(float _freq,char *_labelString);
		 	void setVertexColour(int _x,int _z,int _bandType);

			float labelZ[SIGN_WIDTH][MAXLABELS];
			float labelFrequency[SIGN_WIDTH][MAXLABELS];
			float labelAmp[SIGN_WIDTH][MAXLABELS];
			float labelX[SIGN_WIDTH][MAXLABELS];
			int labels[SIGN_WIDTH];
			
			int peakFrequencies[SIGN_WIDTH];
			
			int pFace[3];
			int pMode[3];
			int pRendering[2];
			int blendFactor[19];
			int sourceBlend;
			int destinationBlend;
			float peakLength;
			float polygonLength;
			float peakArea;
//			int labeled;
			
//			int drawing;
			clock_t lastCall;			
			int lastLabelY;
	};
	
////////////////////////////////
//
//	constructor
//
////////////////////////////////
mesaSpectrogram::mesaSpectrogram(sign &_SIGNPOINTER) : SIGNPOINTER(&_SIGNPOINTER),
																																	 BAND((_GLUfuncptr) &bandEQCB)
																																	 
	{
	#if DEBUG	
		printf("in mesaSpectrogram constructor\n");
	#endif
	
	int x,z,l;
	
	peakLength = 0.0;
	peakArea = 0.0;
//	drawing = 0;

//	labeled = 0;
	polygonLength = 0;
	
	blendFactor[0] = GL_ZERO;
	blendFactor[1] = GL_ONE;
	blendFactor[2] = GL_SRC_COLOR;
	blendFactor[3] = GL_ONE_MINUS_SRC_COLOR;
	blendFactor[4] = GL_DST_COLOR;
	blendFactor[5] = GL_ONE_MINUS_DST_COLOR;
	blendFactor[6] = GL_SRC_ALPHA;
	blendFactor[7] = GL_ONE_MINUS_SRC_ALPHA;
	blendFactor[8] = GL_DST_ALPHA;
	blendFactor[9] = GL_ONE_MINUS_DST_ALPHA;
	blendFactor[10] = GL_CONSTANT_COLOR;
	blendFactor[11] = GL_ONE_MINUS_CONSTANT_COLOR;
	blendFactor[12] = GL_CONSTANT_ALPHA;
	blendFactor[13] = GL_ONE_MINUS_CONSTANT_ALPHA;
	blendFactor[14] = GL_SRC_ALPHA_SATURATE;
	blendFactor[15] = GL_SRC1_COLOR;
	blendFactor[16] = GL_ONE_MINUS_SRC1_COLOR;
	blendFactor[17] = GL_SRC1_ALPHA;
	blendFactor[18] = GL_ONE_MINUS_SRC1_ALPHA;

	pFace[0] = GL_FRONT;
	pFace[1] = GL_BACK;
	pFace[2] = GL_FRONT_AND_BACK;

	pMode[0] = GL_POINT;
	pMode[1] = GL_LINE;
	pMode[2] = GL_FILL;

	pRendering[0]	= GL_CCW;
	pRendering[1]	= GL_CW;
	
	for (x=0;x<SIGN_WIDTH;x++)
 		for(l = 0 ;l < MAXLABELS;l++)	
			{
 	 		labelZ[x][l] = 1; // set to not moving
			labelAmp[x][l] =1.0;
			labelX[x][l] = 1.0;
			labelFrequency[x][l] = 0;
			}

	// flatten spectrogram array
 	for(z=0;z<MAXSPECTROGRAMZ;z++)	
		for (x=0;x<SIGN_WIDTH;x++)
			sg[x][z] = 0;	
/*
	BAND.offsetX = 0.0;
	BAND.offsetY = 0.0;
	BAND.offsetZ = 0.0;
	BAND.speed = 0.0;
	BAND.activeControlPoint = 0.0;
	BAND.percentRandom = 0;
	BAND.controlPointsEdited = 0;
*/
	BAND.controlPoints = 96;//NURBS.MESA.SPLINESPECTROGRAM.depth;
   
 	lastCall = clock();
 	zScaleMS = 100;
   
	inited = 1;
	}
	
////////////////////////////////
//
//	de constructor
//
////////////////////////////////
mesaSpectrogram::~mesaSpectrogram()
	{
 
	}

///////////////////////////////////
//
//			void mesaSpectrogram::addRow(uint *_peak,uint *_peakThreshold)
//
//////////////////////////////
void mesaSpectrogram::addRow(uint *_peak,uint *_peakThreshold)
	{
	int amp,i,x,z,frequencyIndex;	
	
	float elapsedSeconds;

	elapsedSeconds = ((float)clock() - lastCall) / CLOCKS_PER_SEC * 1000.0;
		
	if (elapsedSeconds < zScaleMS)
		return;

	lastCall = clock();		
								
	peakThreshold = _peakThreshold;

	// shift array back 1 ...via z
	for(z=depth - 1;z != 0;z--)	
		for (x=0;x<SIGN_WIDTH;x++)
			 sg[x][z] = sg[x][z - 1];	

	// go thru peaks ...looking for biggest
	for (x = 0 ; x < SIGN_WIDTH- (SIGN_WIDTH / bands); x+= SIGN_WIDTH / bands)
		{	
		// find biggest peak in band range...we have 128 bands...but only
	 	// show 8...16...24 ect...
	 	amp = 0;
	 	
		for (i = 0; i < bands;i++)
			if (_peak[x + i] > amp)
				{
				amp = _peak[x + i];
				frequencyIndex = x + i;
				}
	
		// replace all peaks in band range with biggest peak found
		for (i = 0;i < bands ;i++ )
			{
			peakFrequencies[x + i] = frequencyIndex;
			sg[x + i][0] = amp;
			}
		} // for (x = SIGN_WIDTH - 1;x > 0;x -= SIGN_WIDTH / bands)

	} // void mesaSpectrogram::addRow(uint *_peak,uint *_peakThreshold)

//////////////////////////////////
//
//				void mesaSpectrogram::drawSpectrogram()
//
//////////////////////////////////
void mesaSpectrogram::drawSpectrogram(int _eyeX, int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ,int _sourceBlend,int _destinationBlend)
	{
	int x,z;
	char freq[7];
	float colour;
				 
	if (inited != 1)			
		{
		//		printf("in drawSpectrogram and mesaSpectrogram is %d\n",inited);
		return;
		}

	glPushMatrix();

	sourceBlend = _sourceBlend;
	destinationBlend =_destinationBlend;

	// preserving opacity....
 
	// start @ the origin draw bands from furthest to closest 
	// if we get to camerx....stop
	for (x = 0;x < SIGN_WIDTH  ;x += SIGN_WIDTH / bands)
		{
		if (x > _eyeX - 1) 	
			break;
 
 		theSwitch(x,_eyeX,_centreX,_eyeY,_offsetY,_eyeZ,_offsetZ);
		}

  // finish drawing the rest from furthest to closest
 	// starting from the other end of x axis
	for (x = SIGN_WIDTH - (SIGN_WIDTH / bands);x > -1;x -= SIGN_WIDTH / bands)
		{
		if (x < _eyeX - 1) 	
			break;
			
		theSwitch(x,_eyeX,_centreX,_eyeY,_offsetY,_eyeZ,_offsetZ);
		}

	glPopMatrix();	 	
	}

////////////////////////////////
//
//		void mesaSplineSpectroram::theSwitch(int x)
//
//////////////////////////////////
void mesaSpectrogram::theSwitch(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)
	{
	glBlendFunc( blendFactor[sourceBlend], blendFactor[destinationBlend]);
				
  drawPolygons(_x, _eyeX, _centreX, _eyeY, _offsetY,_eyeZ,_offsetZ);
  drawLineStrip(_x,_eyeX, _centreX, _eyeY, _offsetY,_eyeZ,_offsetZ);
	drawLabels(_x,_eyeX,_eyeY);
	} //void mesaSpectrogram::theSwitch(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)

/////////////////////////////////
//
//	void mesaSpectrogram::drawLineStrip(int _bandType,int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)
//
////////////////////////////////
void mesaSpectrogram::drawLineStrip(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)
	{
	int z,l;
	int amp,threshold,ampMinusOne;
	
	peakLength = 0.0;
	peakArea = 0.0;
	
	lastLabelY = 0;

	for (z = 0;z < depth;z++)
		{
	 	amp = sg[_x][z];
	 	
	 	if (z > 0)
	 		ampMinusOne = sg[_x][z - 1];
	 			else
	 				ampMinusOne = 0;
	 				
 		//amp = 22 * sin(2 * M_PI * ( ((float)z + 1) / (float)depth ));
		
		threshold = peakThreshold[_x] - thresholdRange;

		//////////////////////////
		//
		// start a line strip
		//
		////////////////////////		
		if ((amp > threshold) && (peakLength == 0) && (z != depth - 1))
		    {
//		    	endwin();
//		    printf("found a peak _x = %d z = %d (0,0) (glBegin)\n",_x,-z);	
		    	
		    glBegin(GL_LINE_STRIP);

 				setVertexColour(_x ,z ,GL_LINE_STRIP);

				if (z == 0)
					glVertex3f(_x,
										0.0,
			  						((float)-z ) * zScale );
						else
							glVertex3f(_x,
												0.0,
					  						((float)-z + 1.0) * zScale );

				glVertex3f(_x,
									(amp - threshold) * yScale,
		  						((float)-z ) * zScale );

				lastLabelY = (amp - threshold) * yScale;
		    peakLength = 1.0;
		    peakArea = 0;
 				
 				goto NEXTZ;
 				}
				
		//////////////////////////
		//
 		// keep drawing line strip
		//
		////////////////////////
		if ((amp > threshold)  )
			{
 // 	    printf("continuing to draw line strip (%d,%d,%d) length is %d\n",_x,amp - threshold,-z,peakLength);	
			
			setVertexColour(_x,z , GL_LINE_STRIP);																		
			
			glVertex3f(_x,
								(amp - threshold) * yScale,
		  					((float)-z  ) * zScale );
	
			peakLength++;
 			peakArea += (float)(amp - threshold) * yScale;
 			peakArea *= zScale;

//			if ( ((peakArea > MAXPEAKAREA) && (peakLength > MAXPEAKLENGTH)))
			if ((peakArea > MAXPEAKAREA))// && (lastLabelY > (amp - threshold) * yScale))
				{
				queueLabel(_x ,z ,_eyeX ,_eyeY);
				peakArea = 0;
				}
			}  // keep drawing line strip

		/////////////////////
		//
		// finish drawing line strip
		//
		/////////////////////
		if (((amp < threshold) && (peakLength > 0)) || (z == depth - 1) )
				{
	//			printf("finishing current line strip...reseting z = %d (glEnd)\n",-z);	
				
 				setVertexColour(_x,z , GL_LINE_STRIP);															
			
				glVertex3f(_x ,
									 0.0,
				  				((float)-z  + 1.0  ) * zScale );
				
				glEnd();
					
	 			peakLength = 0.0;	
				peakArea = 0.0;
				} // if ((peakLength > 0) || (peakLength > MAXPEAKLENGTH))
		
		NEXTZ:	
			if (0);
  	} // for (z = 0;z < depth;z++)
	}
	
////////////////////////////////
//
//	void mesaSpectrogram::drawVertexEQBand(int x)
// 				now with goto motherfucker
//
//void mesaSpectrogram::drawPolygons(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)
//
//
// v 11.0...at least
//
// first off....gl only draws CONVEX POLYGONS and doesnt draw concave
//
// you must break up the concave polygons into CONVEX POLYGONS...and draw those
//
////////////////////////////////
void mesaSpectrogram::drawPolygons(int _x,int _eyeX,int _centreX, int _eyeY,int _offsetY,int _eyeZ,int _offsetZ)
	{
	int l,z,flag;
	int loopDebug = 0;
	int amp,ampPlusOne,threshold;
	
	polygonLength = 0.0;

	if (_x < _eyeX - 1) 	
		glFrontFace(GL_CW);
			else
	  		glFrontFace(GL_CCW);
  	  			
 	glPolygonMode(pFace[polygonFace], pMode[polygonMode]);
	glPointSize(1.0);

 	for(z = 0 ;z < depth;z++)	
 		{

	  amp = sg[_x][z];
	 	
	 	if (z > depth - 1) 				
	 		ampPlusOne = 0;
	 			else
				 	ampPlusOne = sg[_x][z + 1];	

 		//amp = 22 * sin(2 * M_PI * ( ((float)z + 1) / (float)depth ));
		
		threshold = peakThreshold[_x] - thresholdRange;

		//////////////////////////
		//
		// start/finish a polygon
		//
		// gl doesnt draw concave polygons
		// split sg array into convex polygons
		//
		////////////////////////
		if ((amp > threshold)  && (polygonLength == 0) && (z != depth - 1))
		    {
		    #if  POLYGONDEBUG	
		    	endwin();	
		    	printf("found a polygon _x = %d z = %d (0,0) amp = %d (glBegin)\n",_x,-z,amp);	
		    #endif
		    
		    glBegin(GL_POLYGON);
 				setVertexColour(_x ,z ,GL_POLYGON);

				glVertex3f(_x,
									0.0,
		  						((float)-z ) * zScale );

				glVertex3f(_x,
									(amp - threshold) * yScale,
		  						((float)-z ) * zScale );

				glVertex3f(_x,
									(ampPlusOne - threshold) * yScale,
		  						((float)-z - 1) * zScale );
	
				glVertex3f(_x,
									0.0,
		  						((float)-z - 1 ) * zScale );
					glEnd();			
		    } 
 	 		} //for(z = 0 ;z < depth ;z++)	
	}

/////////////////////////////////////
//
//		void mesaSpectrogram::queueLabel(int _x,int _z,int _eyeX, int _eyeY)
//
/////////////////////////////////////
void mesaSpectrogram::queueLabel(int _x,int _z,int _eyeX, int _eyeY)
	{
	int amp,threshold,l;
	
 	amp = sg[_x][_z];
 	
	threshold = peakThreshold[_x] - thresholdRange;

	if (amp - threshold < 2)
		return;
 	
	if (labels[_x] > MAXLABELS)					
		return;

	for (l = 0;l < MAXLABELS;l++)
		if (labelZ[_x][l] + (-depth / MAXLABELS) > -_z)
			return;
			
	// find empty queue spot
	for (l = 0;l < MAXLABELS;l++)
		if (labelZ[_x][l] == 1)
			break;

	// didnt find queue spot
	if (labelZ[_x][l] != 1)
		return;
		
 	amp = sg[_x][_z];
						
	threshold = peakThreshold[_x] - thresholdRange;
	
	labelZ[_x][l] = (float)(-_z  ) * zScale;

	labelFrequency[_x][l] = SIGNPOINTER->calcFreq(peakFrequencies[_x],xScale);
//	labelFrequency[_x][l] = SIGNPOINTER->calcFreq(_x + 2);
	
	labelAmp[_x][l] = SIGNPOINTER->fclamp((amp - threshold) * labelYScale,0.001,LABELYMAX);
	
	labelX[_x][l] = (float)peakLength * labelXScale;
//	labelX[_x][l] =  SIGNPOINTER->fclamp((peakLength * 0.125) * labelXScale,0.0,20.0);
	
	labels[_x]++;
	} // void mesaSpectrogram::queueLabel(int _x,int _z,int _eyeX, int _eyeY)

//////////////////////////////////////////
//
//		void drawLabels(int _x,int _eyeX,int _eyeY);
//
/////////////////////////////////////////////////
void mesaSpectrogram::drawLabels(int _x,int _eyeX,int _eyeY)
	{
	int l,c,d;
	float xScale,yScale;
	char rerversedLabel[10];

	if (labels[_x] < 1)
		return;
 	
	for (l = 0;l < MAXLABELS;l++)
		{
		if ( (_x < _eyeX + 16) && (_x > _eyeX - 16))
			goto NEXT;
	
		if (_eyeY > 15)
			goto NEXT;
	
		glPushMatrix();
 
//				glTranslatef(_x  ,
//										0.0,//labelAmp[l] * labelYScale * 0.5,
//										labelZ[_x][l]  );

		freqToString(labelFrequency[_x][l],labelString);

	 
		if (_x > _eyeX )
			{	
			glTranslatef(_x  ,
									labelAmp[_x][l] * labelYScale * 0.5,
									labelZ[_x][l]  );
			
			glRotatef(-90,0.0,1.0,0.0);
			} else {
							glTranslatef(_x  ,
													0.0,//labelAmp[l] * labelYScale * 0.5,
													labelZ[_x][l] + strlen(labelString) + 4);
						
							glRotatef(90,0.0,1.0,0.0);
			
							}

		//glScalef (xScale,	yScale,	1.0);
		glScalef (labelX[_x][l],	labelAmp[_x][l] ,	1.0);
	 
	
		glColor4f(1.0,0.0,0.0,0.0);

		glCallLists(strlen(labelString), GL_BYTE, (char*)labelString);
	
		glPopMatrix();
		
		labelZ[_x][l] -= zScale;
		
		if (labelZ[_x][l] < -depth)
			{
			labelZ[_x][l] = 1;	
			labels[_x]--;	
			}

		NEXT:
			if (0);
				
		} //for (l = 0;l < MAXLABELS;l++)
		
	}	
	
///////////////////////////
//
//				drawNURBSEQBand(x);
//
/////////////////////////////
void mesaSpectrogram::drawNURBSEQBand(int _x)
	{
	int z;
	float colour;
 		 
//  BAND.controlPoints = depth;
	 
	 for(z = 0 ;z < depth;z++)	
	 	{
//	 	BAND.movedcontrolPointsCoords[z] = -1;
	 		
	 	BAND.controlPointsCoords[(z * 4) + 0] = _x;
	 	BAND.controlPointsCoords[(z * 4) + 1] = sg[_x][z];
	 	BAND.controlPointsCoords[(z * 4) + 2] = z;
	 	BAND.controlPointsCoords[(z * 4) + 3] = 1.0;
	 	}

/*
	glBegin(GL_LINE_STRIP);

	 for(z = 0 ;z < BAND.vertices;z+=BAND.vertices/depth)	
	 	{
		
		colour = setVertexColour(x,z);	
		glColor3f(colour,0.0,0.0);
  
    glVertex3f(x,BAND.NURBSx[BAND.vertices], (-z - 1) * zScale);
		}

	glEnd();			
	//BAND.showCurve();
	*/
	}

//////////////////////////////
//
//		void mesaSpectrogram::setVertexColour(int x,int z)
//
/////////////////////////////////
void mesaSpectrogram::setVertexColour(int _x,int _z,int _bandType)
	{
	int amp,threshold;
	
	if (_bandType == GL_POLYGON)
		{
		if (polygonColour > 0.001)
			glColor3f(0.005, 0.0, 0.0);
				else
					glColor4f(0.0, 0.0, 0.0, 0);

		return;	
		}
	
	amp 			= sg[_x][_z];
	threshold = peakThreshold[_x] - thresholdRange; 
			
	if (amp > threshold * 1.4)
		{
		glColor4f(1.0, 0.0, 0.0, 0.0);
		return;
		}

	if (amp > threshold)
		{
		glColor4f(0.005, 0.0, 0.0, 0.0);
		return;
		}

	}

//////////////////////////////////
//
//  char* sign::freqToString(int x)
//
////////////////////////////////
void mesaSpectrogram::freqToString(float _freq,char *_labelString)
	{
	float nIndex;
 	
	// convert float to string
	if (_freq > 1000)
		{
		// if freq is even...dont print beyond decimal			
		if (((int)_freq % 1000) == 0)
			snprintf ( labelString, 10, "%dKHz", (int)_freq / 1000 ); 
				else
					snprintf ( labelString, 10, "%2.1fKHz", _freq / 1000.0); 
		
		} else {
						snprintf ( labelString, 10, "%dHz", (int)_freq ); 
						}
	}

/////////////////////////////////////////
//
// char* freqTonote(freq)
//
/////////////////////////////////////////
void mesaSpectrogram::freqToNote(float _freq,char *_labelString)
	{
	int i,n,octave; 

	char newnotes[12] = {'A','A','B','C','D','D',
									     'E','E','F','F','G','A'};

	char sharps[12] = {' ','#',' ',' ','b',' ',
										 'b',' ',' ','#',' ','b'};

	// thx to suits@mtu.edu (Byran Suits) for this equation
	//n = 39.86314 log(Fn) - 105.37632
	n= (int)(39.86314 * log10(_freq) - 105.37632);
	
	octave=(n / 12) + 4; 
	
	n = n % 12;
	
	if (n < 0)
			n += 11;
	
	//printf("n is %d octave is %d\r",n % 12,octave);
	//	printf("should play a %c%c%d",newnotes[n],sharps[n],octave);
	 
	_labelString[0] = newnotes[n];
	_labelString[1] = sharps[n];
	_labelString[2] = char(octave+48);
	_labelString[3] = '\0';
	}

